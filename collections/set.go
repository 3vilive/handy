// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package collections

type IntSet struct {
	m map[int]struct{}
}

func NewIntSet(elements ...int) *IntSet {
	set := IntSet{
		m: make(map[int]struct{}),
	}
	set.Add(elements...)
	return &set
}

func (s *IntSet) Add(elements ...int) {
	for _, element := range elements {
		s.m[element] = struct{}{}
	}
}

func (s *IntSet) Contain(element int) bool {
	_, exists := s.m[element]
	return exists
}

func (s *IntSet) Elements() []int {
	elements := make([]int, 0, len(s.m))
	for element := range s.m {
		elements = append(elements, element)
	}

	return elements
}

func (s *IntSet) Len() int {
	return len(s.m)
}

func (s *IntSet) IsEmpty() bool {
	return len(s.m) == 0
}

func (s *IntSet) Diff(other *IntSet) *IntSet {
	diff := NewIntSet()
	for elem := range s.m {
		if !other.Contain(elem) {
			diff.Add(elem)
		}
	}
	return diff
}

func (s *IntSet) Intersection(other *IntSet) *IntSet {
	intersection := NewIntSet()
	for elem := range s.m {
		if other.Contain(elem) {
			intersection.Add(elem)
		}
	}
	return intersection
}

func (s *IntSet) Union(other *IntSet) *IntSet {
	union := NewIntSet()
	for elem := range s.m {
		union.Add(elem)
	}
	for elem := range other.m {
		union.Add(elem)
	}
	return union
}

type Int64Set struct {
	m map[int64]struct{}
}

func NewInt64Set(elements ...int64) *Int64Set {
	set := Int64Set{
		m: make(map[int64]struct{}),
	}
	set.Add(elements...)
	return &set
}

func (s *Int64Set) Add(elements ...int64) {
	for _, element := range elements {
		s.m[element] = struct{}{}
	}
}

func (s *Int64Set) Contain(element int64) bool {
	_, exists := s.m[element]
	return exists
}

func (s *Int64Set) Elements() []int64 {
	elements := make([]int64, 0, len(s.m))
	for element := range s.m {
		elements = append(elements, element)
	}

	return elements
}

func (s *Int64Set) Len() int {
	return len(s.m)
}

func (s *Int64Set) IsEmpty() bool {
	return len(s.m) == 0
}

func (s *Int64Set) Diff(other *Int64Set) *Int64Set {
	diff := NewInt64Set()
	for elem := range s.m {
		if !other.Contain(elem) {
			diff.Add(elem)
		}
	}
	return diff
}

func (s *Int64Set) Intersection(other *Int64Set) *Int64Set {
	intersection := NewInt64Set()
	for elem := range s.m {
		if other.Contain(elem) {
			intersection.Add(elem)
		}
	}
	return intersection
}

func (s *Int64Set) Union(other *Int64Set) *Int64Set {
	union := NewInt64Set()
	for elem := range s.m {
		union.Add(elem)
	}
	for elem := range other.m {
		union.Add(elem)
	}
	return union
}

type StringSet struct {
	m map[string]struct{}
}

func NewStringSet(elements ...string) *StringSet {
	set := StringSet{
		m: make(map[string]struct{}),
	}
	set.Add(elements...)
	return &set
}

func (s *StringSet) Add(elements ...string) {
	for _, element := range elements {
		s.m[element] = struct{}{}
	}
}

func (s *StringSet) Contain(element string) bool {
	_, exists := s.m[element]
	return exists
}

func (s *StringSet) Elements() []string {
	elements := make([]string, 0, len(s.m))
	for element := range s.m {
		elements = append(elements, element)
	}

	return elements
}

func (s *StringSet) Len() int {
	return len(s.m)
}

func (s *StringSet) IsEmpty() bool {
	return len(s.m) == 0
}

func (s *StringSet) Diff(other *StringSet) *StringSet {
	diff := NewStringSet()
	for elem := range s.m {
		if !other.Contain(elem) {
			diff.Add(elem)
		}
	}
	return diff
}

func (s *StringSet) Intersection(other *StringSet) *StringSet {
	intersection := NewStringSet()
	for elem := range s.m {
		if other.Contain(elem) {
			intersection.Add(elem)
		}
	}
	return intersection
}

func (s *StringSet) Union(other *StringSet) *StringSet {
	union := NewStringSet()
	for elem := range s.m {
		union.Add(elem)
	}
	for elem := range other.m {
		union.Add(elem)
	}
	return union
}
