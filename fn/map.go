// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package fn

func MapIntToInt(elements []int, fn func(int) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToInt64(elements []int, fn func(int) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToByte(elements []int, fn func(int) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToString(elements []int, fn func(int) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToFloat32(elements []int, fn func(int) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToFloat64(elements []int, fn func(int) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapIntToBool(elements []int, fn func(int) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToInt(elements []int64, fn func(int64) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToInt64(elements []int64, fn func(int64) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToByte(elements []int64, fn func(int64) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToString(elements []int64, fn func(int64) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToFloat32(elements []int64, fn func(int64) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToFloat64(elements []int64, fn func(int64) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapInt64ToBool(elements []int64, fn func(int64) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToInt(elements []byte, fn func(byte) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToInt64(elements []byte, fn func(byte) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToByte(elements []byte, fn func(byte) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToString(elements []byte, fn func(byte) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToFloat32(elements []byte, fn func(byte) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToFloat64(elements []byte, fn func(byte) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapByteToBool(elements []byte, fn func(byte) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToInt(elements []string, fn func(string) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToInt64(elements []string, fn func(string) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToByte(elements []string, fn func(string) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToString(elements []string, fn func(string) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToFloat32(elements []string, fn func(string) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToFloat64(elements []string, fn func(string) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapStringToBool(elements []string, fn func(string) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToInt(elements []float32, fn func(float32) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToInt64(elements []float32, fn func(float32) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToByte(elements []float32, fn func(float32) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToString(elements []float32, fn func(float32) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToFloat32(elements []float32, fn func(float32) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToFloat64(elements []float32, fn func(float32) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat32ToBool(elements []float32, fn func(float32) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToInt(elements []float64, fn func(float64) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToInt64(elements []float64, fn func(float64) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToByte(elements []float64, fn func(float64) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToString(elements []float64, fn func(float64) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToFloat32(elements []float64, fn func(float64) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToFloat64(elements []float64, fn func(float64) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapFloat64ToBool(elements []float64, fn func(float64) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToInt(elements []bool, fn func(bool) int) []int {
	out := make([]int, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToInt64(elements []bool, fn func(bool) int64) []int64 {
	out := make([]int64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToByte(elements []bool, fn func(bool) byte) []byte {
	out := make([]byte, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToString(elements []bool, fn func(bool) string) []string {
	out := make([]string, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToFloat32(elements []bool, fn func(bool) float32) []float32 {
	out := make([]float32, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToFloat64(elements []bool, fn func(bool) float64) []float64 {
	out := make([]float64, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}

func MapBoolToBool(elements []bool, fn func(bool) bool) []bool {
	out := make([]bool, 0, len(elements))
	for _, elem := range elements {
		out = append(out, fn(elem))
	}
	return out
}
